VirtualBox password: "hey, I didn't mean anything"

$ Fill out doodle poll
$ You should delete the old BlimC repo.
    At this point it can only confuse you.
$ Merge old and new repositories

* Uninstall blimpy from the overall system. Create another environment and install vanilla blimpy into that
    * Run unit tests again to make sure that it all still works
* Create another local clone, then replace three files with the contents of src/prototype
    * Keep in mind that these are the latest ideas, so you may fail even more tests
    than you did last time (you failed one test).
    * If you fail more than one test, you may want to revert, piece by piece. A full revert would use the two files "src/file_wrapper.py" and "src/bound_reader.cpp" (no alterations were performed on Danny's "src/setup.py".
    The most likely source of additional failures would be the new bound_reader.cpp.
* Install that in another environment and run unit tests
* Link your Google slides somewhere in your repo
    * Furthermore, I should really include a README.MD, the repo needs to look more professional.

* If the code finally works, run the unit tests several times for each edition, and compile speed results.
* Speed looks good? Ask Yuhong and then Danny Price for advice on further testing.
    * If the speed tests continue to come out positively, we know I can move to a pull request.

------------ Still stuck on the bug?

First try addressing how the start positions differ
    * My best guess: the offset is not added properly. Consider the 
    following non-consecutive lines from the original:
        f.seek(int(self.idx_data))
        f.seek(int(self.t_start * self._n_bytes  * n_ifs * n_chans), 1)
    
        * actually, I have implemented the first line:
            curs += data_index;

        The second definitely is not there, however. What if I could
        conceptually combine the two earlier statements like so:
            f.seek(int(self.idx_data + self.t_start * self._n_bytes  * n_ifs * n_chans))
        
        in which case the call to the C++ module would have 
            self.idx_data + self.t_start * self._n_bytes  * n_ifs * n_chans
        instead of
            self.idx_data

        Now, if this correction (which is currently implemented in the
        prototype folder) does not work, investigate the int-casting
        that was done in the original file_reader, which you did not
        explicitly perform but entrusted to PyBind.

    * My second guess: overflow, somewhere, somehow
        The most likely offender is 'offset'
            offset = i * iScale + j * jScale
        What if you were to make offset a long long int?
            A 32-bit number cannot, for example, hold
            66000^2.
        Do not spend too long on this! In fact, before you touch
        any of the code, first have your program output the
        maximum reached value of offset
            I say, do not spend too long, because
            the third and final bullet point is worth
            investigating, at least cursorily        

    * Consider the following line from the original:
        f = open(self.filename, 'rb')
        does 'rb' mean something particular to my implementation?        

Your proposal has more than enough stuff to work on.

Slack people more often, and keep them posted
