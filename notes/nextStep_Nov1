11/1

* Is there an easy way to return my C++ pointer, that it be
	correctly interpreted in the Python as a numpy array?
* How do I handle the switch from a dynamic to a strong typing environment?
	Specifically, I could pass from Python the data type with which I am
	working. Maybe a job for macros??
		"[PyBind's] goals and syntax are similar to the excellent Boost.Python library
		by David Abrahams: to minimize boilerplate code in traditional extension
		modules by inferring type information using compile-time introspection."

* "Python already handles the header"
	Is this done along with the rest of the reading?
	Because, based on my reading, this action is not made explicit.
* Currently I am parsing by characters. Even if I knew the data type,
	I am not sure how I would parse accordingly. Collect next six bytes and cast?
	If it is any kind of floating-point number, it seems that I would have to
	perform bit-level casting.


	> I didn't actually need VS15 specifically. I think that I just needed
		VS >= VS15
	> You definitely can use default C++ primitives without any fancy
		translation from Python (e.g. in function parameters)

	% Learn about pycast function and its limits

11/14

/home/lfinkbeiner/.conda/envs/AY160/lib/python3.7/site-packages/blimpy

Was I wrong this whole time? .fil is not binary?

11/22

Danny says you can just root through the Python to make the code better.

He also says that running the tests should tell whether you've screwed something up.

Other ideas:
	* Apparently, ephemeris/compute_lsrk.py doesn't work.
	* Allow for the input of astropy-format times, not just Julian.
	* median sucks, it's performing array subtraction and division by hand
		* Much plotting is inefficient (e.g. min/max calculations)
	* Figure out how to get tests' code coverage up to 100%.
		* Will BlimC code degrade this number?

I need to figure out how to install h5py properly, or else I am never going to be able to run these tests!
